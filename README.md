# TopCoder-2017-07-Pathologic-Segmentation
## TopCoder competition Pathology Segmentation jule-august 2017

Jupyter-блокноты с результатами участия в соревновании [Pathology Segmentation](https://community.topcoder.com/tc?module=MatchDetails&rd=16950) на площадке **TopCoder** в июле-августе 2017.

В решении использовались пакеты: Python 2.7, OpenCV, Numpy, Keras, TensorFlow.

Директории содержат:
- [Jupyter-Net](Jupyter-Net) \- блокноты с программным кодом
- [Result](Result) \- результатирующие файлы в директориях с полученным счетом на LB
- [Python](Python) \- выемки наиболее приемлиемых кусков кода python из ноутбуков (UNet, Dice01, ...)
- [Data\-Keras/Optimizer](Data\-Keras/Optimizer) \- результаты по оптимайзерам (черновой вариант)

Блокноты имеют рабочее содержание и самодостаточны для воспроизведения при корректировке путей размещения данных.
Блокноты, которые использовались при получении результата, имеют номер счета в LB в заголовке.
Остальные блокноты имеют рабочее назначение.

Использовалась сеть UNet в стандартной модификации: 32-64-128-256-512-1024-..-32 и уменьшенной 32-..256-512-256-..-32
Использовались разные loss-функции в том числе и экзотические, в основном основанные на bce&dice
Использовалась плата GPU для работы GTX 970.

Полученное место: 26/63. 

Основная причина недостаточный опыт в задачах такого типа и ограниченное количество ресурсов (GPU) для получения
нормального результата в приемлиемое время.

Необходимо было сразу сконцентрироваться на стандартной UNet сети и гнать эпохи до 200-300, не обращая внимания на overfit.
Кроме того вышла накладка с реализацией функции dice и соответственно с loss функцией. 
Dice можно считать двояким образом, как по вероятностными, так с бинаризированными изображениями. 
При одинаковом расчете (dicePP) возникает дисбаланс при подхвате лучших решений в checkpoint.
Видимо лучший вариант: использовать dicePP в loss функции и dice01 в checkpoint на подхвате.

Помещено для сохранения и возможного использования в будущем.
